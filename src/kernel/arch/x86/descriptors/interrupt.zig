///
/// Interrupts are signals from a device (CPU, keyboard, etc)
/// When an interrupt happens, everything stops and the CPU executes another part of
/// the program. Afterwards, the program goes back to what was happening before
///
/// There are 3 types of interrupts:
/// 1. Exceptions: those are generated by the CPU itself and are generally errors
/// 2. Interrupt ReQuests (IRQ) / Hardware Interrupts: those are generated by the chipset, for example, a keypress event in the keyboard
/// 3. Software Interrupts: Those interrupts are generated by software running on the CPU signaling the kernel to do something. Usually, those are system calls
///
/// In order to know what to do when an interrupt happens, we use the IDT (Interrupt Descriptor Table)
/// This table is responsible to map the handler for each interrupt
///
/// Exceptions:
/// The exceptions are CPU "errors". Some of those halt the whole OS, some of those
/// only print an error and the execution can continue. The Exceptions have the first
/// 32 entries in the table reserved [0-31]. Each entry represents a different exception
///
const std = @import("std");
const global = @import("global.zig");
const exceptions = @import("../interrupts/exceptions.zig");
const pic = @import("../interrupts/pic.zig");

const MAX_DESCRIPTORS = 256;
pub const CPU_DESCRIPTORS = 32;

// Entry is an entry of the Interrupt Descriptor Table
// It basically contains the pointer to the handler (isr_low + isr_high)
// and some extra information
const Entry = packed struct {
    isr_low: u16,
    selector: u16,
    // _reserved needs to always be 0
    _reserved: u8 = 0,
    // TODO: Document why the attribites needs to be 0x8e
    type_attributes: u8 = 0x8e,
    isr_high: u16,
};

const TableRegistry = packed struct {
    limit: u16,
    base: u32,
};

var table = std.mem.zeroes([MAX_DESCRIPTORS]Entry);

// An ISR Stub is the Interrupt Service Routine (interrupt handler) that is called
// directly by the CPU when an interrupt happens
const IsrStub = fn () callconv(.Naked) noreturn;

// This generates the ISR stubs
pub fn generateIsrStub(interrupt: u32, handler_name: []const u8) IsrStub {
    return struct {
        fn _() callconv(.Naked) noreturn {
            asm volatile (std.fmt.comptimePrint(
                // Set the interrupt number as the first argument to the function call
                    \\ pushl %[itrpt]

                    // Call the handler
                    \\ call {s}

                    // Clear the first argument of the function call (push 4 bytes to the stack)
                    \\ addl $4, %esp

                    // Return to the program execution afterwards
                    \\ iret
                , .{handler_name})
                :
                : [itrpt] "r" (interrupt),
            );
        }
    }._;
}

fn addStubToTable(i: usize, stub: *const IsrStub) void {
    table[i] = .{
        // Set the isr lower bits of the address of the handler
        .isr_low = @truncate(@intFromPtr(stub)),
        // Set the isr high bits of the address of the handler
        .isr_high = @truncate(@intFromPtr(stub) >> 16),
        // Set this value to the kernel code selector of the GDT
        .selector = global.KERNEL_MODE_CODE_SELECTOR_OFFSET,
    };
}

pub fn init() void {
    // Generate the IDT entries for the Exception interrupts (CPU errors)
    inline for (0..CPU_DESCRIPTORS) |i| {
        const stub = generateIsrStub(@intCast(i), exceptions.HANDLER_NAME);

        // Generate the table entry
        addStubToTable(i, &stub);
    }

    // Generate the IDT entries for the Hardware interrupts
    inline for (CPU_DESCRIPTORS..CPU_DESCRIPTORS + (pic.PIC_IRQ_NUMBER * pic.PIC_NUMBER)) |i| {
        const stub = generateIsrStub(@intCast(i), pic.HANDLER_NAME);

        // Generate the table entry
        addStubToTable(i, &stub);
    }

    const table_registry = TableRegistry{
        .limit = @sizeOf(Entry) * MAX_DESCRIPTORS - 1,
        .base = @intFromPtr(&table[0]),
    };

    // Load the interrupt descriptor table register
    asm volatile (
        \\ lidt %[tbl_reg]
        :
        : [tbl_reg] "*p" (&table_registry),
    );
}
